/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import javax.swing.Timer;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.Component;

/**
 *
 * @author 069949345
 */

public class NewJFrame extends javax.swing.JFrame {
    
    private int arrayWidth = 70;
    private int arrayHeight = 50;
    private boolean[][] currentTurn = new boolean[arrayWidth][arrayHeight];
    private boolean[][] previousTurn = new boolean[arrayWidth][arrayHeight];
    
    

    /**
     * Creates new form NewJFrame
     */
    public NewJFrame() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jButton3 = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jPanel1MouseClicked(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 500, Short.MAX_VALUE)
        );

        jLabel2.setText("Ready to Enter Cells?");

        jButton1.setText("Yes");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton2.setText("Begin Game!");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jLabel1.setText("Preset Configurations:");

        jButton3.setText("Cross!");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        jButton4.setText("Galaxy!");
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton1)
                        .addGap(225, 225, 225)
                        .addComponent(jButton2)
                        .addGap(0, 197, Short.MAX_VALUE)))
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addGap(39, 39, 39)
                .addComponent(jLabel1)
                .addGap(29, 29, 29)
                .addComponent(jButton3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jButton4)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jButton1)
                    .addComponent(jButton2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jButton3)
                    .addComponent(jButton4))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Action block draws the grid
     * First, the jPanel becomes visible and the Graphics variable is initialized
     * the block draws the horizontal lines starting at the top left corner and continuing
     * thereafter 10 pixels apart, with each line going to the bottom of the grid
     * the block then does the same for the vertical lines
     * @param evt 
     */
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        jPanel1.setVisible(true);
        Graphics gfx = jPanel1.getGraphics();
        
        int xVal = 0;
        for (int tickNum = 0; tickNum <= arrayWidth; tickNum ++) {
            gfx.drawLine(xVal, 0, xVal, arrayHeight * 10 - 10);
            xVal += 10;
        }
        int yVal = 0;
        for (int tickNum = 0; tickNum <= arrayHeight; tickNum ++) {
            gfx.drawLine(0, yVal, arrayWidth * 10 - 10, yVal);
            yVal += 10;
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        
        
        
        
        
        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new NewJFrame().setVisible(true);
            }
        });
    }
    
    /**
     * The action block draws a red square where the user has clicked
     * The Graphics variable is initialized
     * First, it gets the x and y pixel coordinates of where the click occurred
     * These values are rounded to the nearest 10 by dividing them by 10, casting them to
     * integers, therefore dropping the decimal, and multiplying them by 10 once more
     * The action block sets the color to red, declares the boolean at the spot in previousTurn
     * that corresponds with the X and Y coordinates to be true, and drawing a square at the spot 
     * that was clicked
     * This makes the cell where the user clicks living
     * @param evt 
     */
    private void jPanel1MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jPanel1MouseClicked
        // TODO add your handling code here:
        Graphics gfx = jPanel1.getGraphics();
        int mouseX = evt.getX();
        int mouseY = evt.getY();
        mouseX = (int)mouseX/10;
        mouseY = (int)mouseY/10;
        
        mouseX = mouseX * 10;
        mouseY = mouseY * 10;
        
        Color red = new Color(255, 0 , 0);
        gfx.setColor(red);
        previousTurn[mouseX/10][mouseY/10] = true;
        gfx.fillRect(mouseX + 1, mouseY + 1, 9, 9);
    }//GEN-LAST:event_jPanel1MouseClicked

    /**
     * This action block serves to keep the game running as long as at least one
     * cell is still alive
     * the jPanel is set to visible and the Graphics variable is initialized
     * The color is set to red
     * while at least one cell is alive, the block calls the checkSquares method using previousTurn and 
     * stores the resulting array in the currentTurn array
     * allAlive is set to false
     * first, the program goes through currentTurn and draws new squares in the jPanel
     * corresponding with where living cells appear in the currentTurn array
     * At the same time, it sets allAlive to true, meaning that the loop will always
     * run as long as at least one cell is alive
     * For non-living cells in the array, the block instead clears the corresponding cell
     * finally, once the entire array has been checked through, previousTurn takes the value
     * of currentTurn and the loop begins once again to begin the next turn
     * @param evt 
     */
    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        // TODO add your handling code here:
        
        Graphics gfx = jPanel1.getGraphics();
        Color red = new Color(255, 0, 0);
        gfx.setColor(red);
        
        boolean lilSquare = false;
        boolean allAlive = true;
        
        while (allAlive == true) {
            allAlive = false;
            currentTurn = checkSquares(previousTurn);
            
            for (int var = 0; var < arrayWidth; var ++) {
                gfx.setColor(red);
                for (int var2 = 0; var2 < arrayHeight; var2 ++) {
                    if (currentTurn[var][var2] == true) {
                        allAlive = true;
                        gfx.fillRect((var * 10) + 1, (var2 * 10) + 1, 9, 9);
                    }
                    else {
                        gfx.clearRect((var * 10) + 1, (var2 * 10) + 1, 9, 9);
                    }
                }
            }
            previousTurn = currentTurn;
        }
    }//GEN-LAST:event_jButton2ActionPerformed

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        // TODO add your handling code here:
        jPanel1.setVisible(true);
        Graphics gfx = jPanel1.getGraphics();
        Color red = new Color(255, 0, 0);
        gfx.setColor(red);
        
        previousTurn[53][31] = true;
        gfx.fillRect(53 * 10 + 1, 31 * 10 + 1, 9, 9);
        previousTurn[54][31] = true;
        gfx.fillRect(54 * 10 + 1, 31 * 10 + 1, 9, 9);
        previousTurn[55][31] = true;
        gfx.fillRect(55 * 10 + 1, 31 * 10 + 1, 9, 9);
        previousTurn[56][31] = true;
        gfx.fillRect(56 * 10 + 1, 31 * 10 + 1, 9, 9);
        previousTurn[56][32] = true;
        gfx.fillRect(56 * 10 + 1, 32 * 10 + 1, 9, 9);
        previousTurn[56][33] = true;
        gfx.fillRect(56 * 10 + 1, 33 * 10 + 1, 9, 9);
        previousTurn[57][33] = true;
        gfx.fillRect(57 * 10 + 1, 33 * 10 + 1, 9, 9);
        previousTurn[58][33] = true;
        gfx.fillRect(58 * 10 + 1, 33 * 10 + 1, 9, 9);
        previousTurn[58][34] = true;
        gfx.fillRect(58 * 10 + 1, 34 * 10 + 1, 9, 9);
        previousTurn[58][35] = true;
        gfx.fillRect(58 * 10 + 1, 35 * 10 + 1, 9, 9);
        previousTurn[58][36] = true;
        gfx.fillRect(58 * 10 + 1, 36 * 10 + 1, 9, 9);
        previousTurn[57][36] = true;
        gfx.fillRect(57 * 10 + 1, 36 * 10 + 1, 9, 9);
        previousTurn[56][36] = true;
        gfx.fillRect(56 * 10 + 1, 36 * 10 + 1, 9, 9);
        previousTurn[56][37] = true;
        gfx.fillRect(56 * 10 + 1, 37 * 10 + 1, 9, 9);
        previousTurn[56][38] = true;
        gfx.fillRect(56 * 10 + 1, 38 * 10 + 1, 9, 9);
        previousTurn[55][38] = true;
        gfx.fillRect(55 * 10 + 1, 38 * 10 + 1, 9, 9);
        previousTurn[54][38] = true;
        gfx.fillRect(54 * 10 + 1, 38 * 10 + 1, 9, 9);
        previousTurn[53][38] = true;
        gfx.fillRect(53 * 10 + 1, 38 * 10 + 1, 9, 9);
        previousTurn[53][37] = true;
        gfx.fillRect(53 * 10 + 1, 37 * 10 + 1, 9, 9);
        previousTurn[53][36] = true;
        gfx.fillRect(53 * 10 + 1, 36 * 10 + 1, 9, 9);
        previousTurn[52][36] = true;
        gfx.fillRect(52 * 10 + 1, 36 * 10 + 1, 9, 9);
        previousTurn[51][36] = true;
        gfx.fillRect(51 * 10 + 1, 36 * 10 + 1, 9, 9);
        previousTurn[51][35] = true;
        gfx.fillRect(51 * 10 + 1, 35 * 10 + 1, 9, 9);
        previousTurn[51][34] = true;
        gfx.fillRect(51 * 10 + 1, 34 * 10 + 1, 9, 9);
        previousTurn[51][33] = true;
        gfx.fillRect(51 * 10 + 1, 33 * 10 + 1, 9, 9);
        previousTurn[52][33] = true;
        gfx.fillRect(52 * 10 + 1, 33 * 10 + 1, 9, 9);
        previousTurn[53][33] = true;
        gfx.fillRect(53 * 10 + 1, 33 * 10 + 1, 9, 9);
        previousTurn[53][32] = true;
        gfx.fillRect(53 * 10 + 1, 32 * 10 + 1, 9, 9);
        
    }//GEN-LAST:event_jButton3ActionPerformed

    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed
        // TODO add your handling code here:
        jPanel1.setVisible(true);
        Graphics gfx = jPanel1.getGraphics();
        Color red = new Color(255, 0, 0);
        gfx.setColor(red);
        
        previousTurn[13][21] = true;
        gfx.fillRect(13 * 10 + 1, 21 * 10 + 1, 9, 9);
        previousTurn[14][21] = true;
        gfx.fillRect(14 * 10 + 1, 21 * 10 + 1, 9, 9);
        previousTurn[13][22] = true;
        gfx.fillRect(13 * 10 + 1, 22 * 10 + 1, 9, 9);
        previousTurn[14][22] = true;
        gfx.fillRect(14 * 10 + 1, 22 * 10 + 1, 9, 9);
        previousTurn[13][23] = true;
        gfx.fillRect(13 * 10 + 1, 23 * 10 + 1, 9, 9);
        previousTurn[14][23] = true;
        gfx.fillRect(14 * 10 + 1, 23 * 10 + 1, 9, 9);
        previousTurn[13][24] = true;
        gfx.fillRect(13 * 10 + 1, 24 * 10 + 1, 9, 9);
        previousTurn[14][24] = true;
        gfx.fillRect(14 * 10 + 1, 24 * 10 + 1, 9, 9);
        previousTurn[13][25] = true;
        gfx.fillRect(13 * 10 + 1, 25 * 10 + 1, 9, 9);
        previousTurn[14][25] = true;
        gfx.fillRect(14 * 10 + 1, 25 * 10 + 1, 9, 9);
        previousTurn[13][26] = true;
        gfx.fillRect(13 * 10 + 1, 26 * 10 + 1, 9, 9);
        previousTurn[13][26] = true;
        gfx.fillRect(13 * 10 + 1, 26 * 10 + 1, 9, 9);
        previousTurn[14][26] = true;
        gfx.fillRect(14 * 10 + 1, 26 * 10 + 1, 9, 9);
        
        previousTurn[13][28] = true;
        gfx.fillRect(13 * 10 + 1, 28 * 10 + 1, 9, 9);
        previousTurn[13][29] = true;
        gfx.fillRect(13 * 10 + 1, 29 * 10 + 1, 9, 9);
        previousTurn[14][28] = true;
        gfx.fillRect(14 * 10 + 1, 28 * 10 + 1, 9, 9);
        previousTurn[14][29] = true;
        gfx.fillRect(14 * 10 + 1, 29 * 10 + 1, 9, 9);
        previousTurn[15][28] = true;
        gfx.fillRect(15 * 10 + 1, 28 * 10 + 1, 9, 9);
        previousTurn[15][29] = true;
        gfx.fillRect(15 * 10 + 1, 29 * 10 + 1, 9, 9);
        previousTurn[16][28] = true;
        gfx.fillRect(16 * 10 + 1, 28 * 10 + 1, 9, 9);
        previousTurn[16][29] = true;
        gfx.fillRect(16 * 10 + 1, 29 * 10 + 1, 9, 9);
        previousTurn[17][28] = true;
        gfx.fillRect(17 * 10 + 1, 28 * 10 + 1, 9, 9);
        previousTurn[17][29] = true;
        gfx.fillRect(17 * 10 + 1, 29 * 10 + 1, 9, 9);
        previousTurn[18][28] = true;
        gfx.fillRect(18 * 10 + 1, 28 * 10 + 1, 9, 9);
        previousTurn[18][29] = true;
        gfx.fillRect(18 * 10 + 1, 29 * 10 + 1, 9, 9);
        
        previousTurn[20][29] = true;
        gfx.fillRect(20 * 10 + 1, 29 * 10 + 1, 9, 9);
        previousTurn[21][29] = true;
        gfx.fillRect(21 * 10 + 1, 29 * 10 + 1, 9, 9);
        previousTurn[20][28] = true;
        gfx.fillRect(20 * 10 + 1, 28 * 10 + 1, 9, 9);
        previousTurn[21][28] = true;
        gfx.fillRect(21 * 10 + 1, 28 * 10 + 1, 9, 9);
        previousTurn[20][27] = true;
        gfx.fillRect(20 * 10 + 1, 27 * 10 + 1, 9, 9);
        previousTurn[21][27] = true;
        gfx.fillRect(21 * 10 + 1, 27 * 10 + 1, 9, 9);
        previousTurn[20][26] = true;
        gfx.fillRect(20 * 10 + 1, 26 * 10 + 1, 9, 9);
        previousTurn[21][26] = true;
        gfx.fillRect(21 * 10 + 1, 26 * 10 + 1, 9, 9);
        previousTurn[20][25] = true;
        gfx.fillRect(20 * 10 + 1, 25 * 10 + 1, 9, 9);
        previousTurn[21][25] = true;
        gfx.fillRect(21 * 10 + 1, 25 * 10 + 1, 9, 9);
        previousTurn[20][24] = true;
        gfx.fillRect(20 * 10 + 1, 24 * 10 + 1, 9, 9);
        previousTurn[21][24] = true;
        gfx.fillRect(21 * 10 + 1, 24 * 10 + 1, 9, 9);
        
        previousTurn[21][22] = true;
        gfx.fillRect(21 * 10 + 1, 22 * 10 + 1, 9, 9);
        previousTurn[21][21] = true;
        gfx.fillRect(21 * 10 + 1, 21 * 10 + 1, 9, 9);
        previousTurn[20][22] = true;
        gfx.fillRect(20 * 10 + 1, 22 * 10 + 1, 9, 9);
        previousTurn[20][21] = true;
        gfx.fillRect(20 * 10 + 1, 21 * 10 + 1, 9, 9);
        previousTurn[19][22] = true;
        gfx.fillRect(19 * 10 + 1, 22 * 10 + 1, 9, 9);
        previousTurn[19][21] = true;
        gfx.fillRect(19 * 10 + 1, 21 * 10 + 1, 9, 9);
        previousTurn[18][22] = true;
        gfx.fillRect(18 * 10 + 1, 22 * 10 + 1, 9, 9);
        previousTurn[18][21] = true;
        gfx.fillRect(18 * 10 + 1, 21 * 10 + 1, 9, 9);
        previousTurn[17][22] = true;
        gfx.fillRect(17 * 10 + 1, 22 * 10 + 1, 9, 9);
        previousTurn[17][21] = true;
        gfx.fillRect(17 * 10 + 1, 21 * 10 + 1, 9, 9);
        previousTurn[16][22] = true;
        gfx.fillRect(16 * 10 + 1, 22 * 10 + 1, 9, 9);
        previousTurn[16][21] = true;
        gfx.fillRect(16 * 10 + 1, 21 * 10 + 1, 9, 9);
    }//GEN-LAST:event_jButton4ActionPerformed
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JPanel jPanel1;
    // End of variables declaration//GEN-END:variables
    
    /**
     * method takes the array of the previous turn and checks it to create the array
     * of the next turn accordingly
     * The program checks each cell by x value and then by y value, thus checking the grid
     * column by column
     * If the current cell, prevTurn[heck1][heck2] is alive, or true, the method checks the cells around it, which 
     * are within at least 1 cell left, right, up and/or down from the current cell, using var1 and var2
     * If one of these neighbor cells is alive, the method increases numFull, the variable which
     * holds the number of living neighbors, by one - unless the cell it is currently checking
     * is the original cell itself, meaning that both var1 and var2 are equal to heck1 and heck2
     * then, the program checks the value of numFull and updates the array for the next turn accordingly
     * if numFull is less than 2, curTurn[heck1][heck2] will be dead from loneliness
     * if numFull is greater than 3, curTurn[heck1][heck2] will be dead from overpopulation
     * if numFull is equal to 2 or 3, curTurn[heck1][heck2] will continue to be alive
     * if prevTurn[heck1][heck2] is dead, the method does the same thing, only
     * if numFull is equal to 3, curTurn[heck1][heck2] will have new life
     * otherwise, curTurn[heck1][heck2] will continue to be dead
     * finally, once the entire grid has been checked, the method returns curTurn to the button2ActionPerformed block
     * @param prevTurn
     * @return 
     */
    public boolean[][] checkSquares(boolean[][] prevTurn) {
        boolean[][]curTurn = new boolean[arrayWidth][arrayHeight];
        int numFull = 0;
        
        for (int heck1 = 0; heck1 < arrayWidth; heck1 ++) {
            for (int heck2 = 0; heck2 < arrayHeight; heck2 ++) {
                if (prevTurn[heck1][heck2] == true) {
                    try {
                        for (int var1 = heck1 - 1; var1 <= heck1 + 1; var1 ++) {
                            for (int var2 = heck2 - 1; var2 <= heck2 + 1; var2 ++) {
                                if (prevTurn[var1][var2] == true){
                                    if (var1 != heck1 || var2 != heck2) {
                                        numFull ++;
                                    }
                                }
                            }
                        }
                    }
                    catch (ArrayIndexOutOfBoundsException noSquares) {
                    
                    }
                    if (numFull <= 1) {
                        curTurn[heck1][heck2] = false;
                    }
                    else if (numFull >= 4) {
                        curTurn[heck1][heck2] = false;
                    }
                    else if (numFull == 2 || numFull == 3){
                        curTurn[heck1][heck2] = true;
                    }
                    numFull = 0;
                }
                else {
                    try {
                        for (int var1 = heck1 - 1; var1 <= heck1 + 1; var1 ++) {
                            for (int var2 = heck2 - 1; var2 <= heck2 + 1; var2 ++) {
                                if (prevTurn[var1][var2] == true){
                                    if (var1 != heck1 || var2 != heck2) {
                                        numFull ++;
                                    }
                                }
                            }
                        }
                    }
                    catch (ArrayIndexOutOfBoundsException noSquares) {
                    
                    }
                    
                    if (numFull == 3) {
                        curTurn[heck1][heck2] = true;
                    }
                    else {
                        curTurn[heck1][heck2] = false;
                    }
                    numFull = 0;
                }
            }
        }
        return curTurn;
    }
    
}
